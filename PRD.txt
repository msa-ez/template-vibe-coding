Please implement DDD-based microservice architecture code for an event storming model-based domain using Spring Boot 3 and DDD Extension. The code must be implemented strictly based on the metadata provided below:

{{namePascalCase}} Metadata:
{{{contexts.json}}}


<function>
var cache = []
const includingKeys = ["", "_type", "fieldDescriptors", "className", "displayName", "events", "aggregateRoot", "aggregates", "policies", "incomingRelations", "source", "commands", "readModels", "queryOption", "queryParameters", "actors", "name", "examples", "given", "when", "then", "value", "type", "controllerInfo", "isRestRepository", "restRepositoryInfo", "apiPath", "method", "fullApiPath", "lifeCycles", "trigger", "annotataion", "entities", "relations", "targetElement", "items"]

function customStringify(obj, cache = new Set(), parentType = null, parentKey = null, path = []) {
    if (obj === null || typeof obj !== 'object') {
        return JSON.stringify(obj);
    }

    // 빈 배열인 경우만 필터링
    if (Array.isArray(obj) && obj.length === 0) {
        return null;
    }

    if (cache.has(obj)) {
        return '{}'; // 순환 참조 처리
    }

    cache.add(obj);
    
    // 현재 경로 업데이트
    const currentPath = [...path];
    if (parentKey) currentPath.push(parentKey);

    if (Array.isArray(obj)) {
        const items = obj.map(item => customStringify(item, cache, parentType, parentKey, currentPath))
                        .filter(item => item !== null);
        cache.delete(obj);
        
        if (items.length === 0) {
            return null;
        }
        
        return `[${items.join(',')}]`;
    }

    const pairs = [];
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (isNaN(key) && !includingKeys.includes(key)) continue;

            let value = obj[key];
            if (value === null) continue;
            
            if (key === 'incomingRelations' && !currentPath.includes('policies')) {
                continue;
            }
            
            if (key === 'relations' && currentPath.includes('entities') && currentPath.includes('relations')) {
                continue;
            }
            
            if (key === 'fieldDescriptors' && currentPath.includes('source')) {
                continue;
            }

            if (key === "_type" && typeof value === 'string' && value.indexOf('.') > 1) {
                value = value.split(".").pop();
            }

            // value 키의 실제 내용을 항상 포함하도록 처리
            const stringifiedValue = customStringify(value, cache, obj.type || parentType, key, currentPath);
            
            // 값이 null인 경우에도 value 키는 항상 처리
            if (key === 'value') {
                // value 키의 경우 원래 값이 있으면 그대로 사용
                pairs.push(`"${key}":${stringifiedValue || '{}'}`);
            } else {
                // 다른 키는 null이면 건너뛰기
                if (stringifiedValue === null) continue;
                pairs.push(`"${key}":${stringifiedValue}`);
            }
        }
    }

    cache.delete(obj);
    return pairs.length > 0 ? `{${pairs.join(',')}}` : null;
}

// customStringify 함수 적용
this.contexts.json = customStringify(this);
</function>
